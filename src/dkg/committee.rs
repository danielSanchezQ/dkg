//! Implementation of the distributed key generation (DKG)
//! procedure presented by Gennaro, Jarecki, Krawczyk and Rabin in
//! ["Secure distributed key generation for discrete-log based cryptosystems."](https://link.springer.com/article/10.1007/s00145-006-0347-3).
//! The distinction with the original protocol lies in the use of hybrid
//! encryption. We use the description and notation presented in the technical
//! [spec](https://github.com/input-output-hk/treasury-crypto/blob/master/docs/voting_protocol_spec/Treasury_voting_protocol_spec.pdf),
//! written by Dmytro Kaidalov.

use super::procedure_keys::{
    MemberCommunicationKey, MemberCommunicationPublicKey, MemberPublicShare, MemberSecretShare,
};
use crate::cryptography::elgamal::SymmetricKey;
use crate::cryptography::{
    commitment::CommitmentKey,
    correct_hybrid_decryption_key::CorrectHybridDecrKeyZkp,
    elgamal::{HybridCiphertext, PublicKey, SecretKey},
};
use crate::errors::DkgError;
use crate::polynomial::Polynomial;
use crate::traits::{PrimeGroupElement, Scalar};
use rand_core::{CryptoRng, RngCore};

pub type DistributedKeyGeneration<G> = MemberState1<G>;

/// Initial state generated by a Member, corresponding to round 1.
#[derive(Clone)]
pub struct MemberState1<G: PrimeGroupElement> {
    sk_share: MemberSecretShare<G>,
    threshold: usize,
    nr_members: usize,
    owner_index: usize,
    ck: CommitmentKey<G>,
    apubs: Vec<G>,
    coeff_comms: Vec<G>,
    encrypted_shares: Vec<IndexedEncryptedShares<G>>,
}

/// State of the member corresponding to round 2.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct MemberState2<G: PrimeGroupElement> {
    threshold: usize,
    misbehaving_parties: Vec<MisbehavingPartiesState1<G>>,
}

/// Type that contains the index of the receiver, and its two encrypted
/// shares.
pub(crate) type IndexedEncryptedShares<G> = (usize, HybridCiphertext<G>, HybridCiphertext<G>);

/// Type that contains misbehaving parties detected in round 1. These
/// consist of the misbehaving member's index, the error which failed,
/// and a proof of correctness of the misbehaviour claim.
type MisbehavingPartiesState1<G> = (usize, DkgError, ProofOfMisbehaviour<G>);

#[derive(Clone, Debug, Eq, PartialEq)]
struct ProofOfMisbehaviour<G: PrimeGroupElement> {
    symm_key_1: SymmetricKey<G>,
    symm_key_2: SymmetricKey<G>,
    encrypted_shares: IndexedEncryptedShares<G>,
    proof_decryption_1: CorrectHybridDecrKeyZkp<G>,
    proof_decryption_2: CorrectHybridDecrKeyZkp<G>,
}

impl<G: PrimeGroupElement> ProofOfMisbehaviour<G> {
    fn generate<R>(
        encrypted_shares: &IndexedEncryptedShares<G>,
        secret_key: &MemberCommunicationKey<G>,
        rng: &mut R,
    ) -> Self
    where
        R: CryptoRng + RngCore,
    {
        let symm_key_1 = secret_key.0.recover_symmetric_key(&encrypted_shares.1);
        let symm_key_2 = secret_key.0.recover_symmetric_key(&encrypted_shares.2);

        let proof_decryption_1 = CorrectHybridDecrKeyZkp::generate(
            &encrypted_shares.1,
            &secret_key.to_public(),
            &symm_key_1,
            secret_key,
            rng,
        );
        let proof_decryption_2 = CorrectHybridDecrKeyZkp::generate(
            &encrypted_shares.2,
            &secret_key.to_public(),
            &symm_key_2,
            secret_key,
            rng,
        );

        Self {
            symm_key_1,
            symm_key_2,
            encrypted_shares: encrypted_shares.clone(),
            proof_decryption_1,
            proof_decryption_2,
        }
    }

    // todo: we probably want to make the verifier input the Hybrid ctxt.
    pub fn verify(
        &self,
        complaining_pk: &MemberCommunicationPublicKey<G>,
        fetched_data: &MembersFetchedState1<G>,
        commitment_key: &CommitmentKey<G>,
        plaintiff_index: usize,
        threshold: usize,
    ) -> Result<(), DkgError> {
        if self
            .proof_decryption_1
            .verify(
                &fetched_data.indexed_shares.1,
                &self.symm_key_1,
                complaining_pk,
            )
            .is_err()
            || self
                .proof_decryption_2
                .verify(
                    &fetched_data.indexed_shares.2,
                    &self.symm_key_2,
                    complaining_pk,
                )
                .is_err()
        {
            return Err(DkgError::InvalidProofOfMisbehaviour);
        }

        let plaintext_1 = match <G::CorrespondingScalar as Scalar>::from_bytes(
            &self.symm_key_1.process(&self.encrypted_shares.1.e2),
        ) {
            Some(scalar) => scalar,
            None => return Err(DkgError::DecodingToScalarFailed),
        };

        let plaintext_2 = match <G::CorrespondingScalar as Scalar>::from_bytes(
            &self.symm_key_2.process(&self.encrypted_shares.2.e2),
        ) {
            Some(scalar) => scalar,
            None => return Err(DkgError::DecodingToScalarFailed),
        };

        let index_pow = <G::CorrespondingScalar as Scalar>::from_u64(plaintiff_index as u64)
            .exp_iter()
            .take(threshold + 1);

        let check_element = commitment_key.h * plaintext_1 + G::generator() * plaintext_2;
        let multi_scalar =
            G::vartime_multiscalar_multiplication(index_pow, fetched_data.clone().committed_coeffs);

        if check_element != multi_scalar {
            return Err(DkgError::InvalidProofOfMisbehaviour);
        }

        Ok(())
    }
}

/// State of the members after round 1. This structure contains the indexed encrypted
/// shares of every other participant, `indexed_shares`, and the committed coefficients
/// of the generated polynomials, `committed_coeffs`.
#[derive(Clone)]
pub struct MembersFetchedState1<G: PrimeGroupElement> {
    indexed_shares: IndexedEncryptedShares<G>,
    committed_coeffs: Vec<G>,
}

impl<G: PrimeGroupElement> MembersFetchedState1<G> {
    fn get_index(&self) -> usize {
        self.indexed_shares.0
    }
}

impl<G: PrimeGroupElement> MemberState1<G> {
    /// Generate a new member state from random. This is round 1 of the protocol. Receives as
    /// input the threshold `t`, the expected number of participants, `n`, common reference string
    /// `crs`, `committee_pks`, and the party's index `my`. Initiates a Pedersen-VSS as a dealer,
    /// and returns the committed coefficients of its polynomials, together with encryption of the
    /// shares of the other different members.
    pub fn init<R: RngCore + CryptoRng>(
        rng: &mut R,
        t: usize,
        n: usize,
        ck: &CommitmentKey<G>,
        committee_pks: &[MemberCommunicationPublicKey<G>],
        my: usize,
    ) -> MemberState1<G> {
        assert_eq!(committee_pks.len(), n);
        assert!(t > 0);
        assert!(t <= n);
        assert!(t > n / 2);
        assert!(my < n);

        let pcomm = Polynomial::<G::CorrespondingScalar>::random(rng, t);
        let pshek = Polynomial::<G::CorrespondingScalar>::random(rng, t);

        let mut apubs = Vec::with_capacity(t);
        let mut coeff_comms = Vec::with_capacity(t);

        for (ai, &bi) in pshek.get_coefficients().zip(pcomm.get_coefficients()) {
            let apub = G::generator() * ai;
            let coeff_comm = (ck.h * bi) + apub;
            apubs.push(apub);
            coeff_comms.push(coeff_comm);
        }

        let mut encrypted_shares: Vec<IndexedEncryptedShares<G>> = Vec::with_capacity(n - 1);
        #[allow(clippy::needless_range_loop)]
        for i in 0..n {
            // don't generate share for self
            if i == my {
                continue;
            } else {
                let idx = <G::CorrespondingScalar as Scalar>::from_u64((i + 1) as u64);
                let share_comm = pcomm.evaluate(&idx);
                let share_shek = pshek.evaluate(&idx);

                let pk = &committee_pks[i];

                let ecomm = pk.hybrid_encrypt(&share_comm.to_bytes(), rng);
                let eshek = pk.hybrid_encrypt(&share_shek.to_bytes(), rng);

                encrypted_shares.push((i, ecomm, eshek));
            }
        }

        MemberState1 {
            sk_share: MemberSecretShare(SecretKey {
                sk: pshek.at_zero(),
            }),
            ck: *ck,
            threshold: t,
            nr_members: n,
            owner_index: my + 1, // committee member are 1-indexed
            apubs,
            coeff_comms,
            encrypted_shares,
        }
    }

    /// Function to proceed to phase 2. It checks and keeps track of misbehaving parties. If this
    /// step does not validate, the member is not allowed to proceed to phase 3.
    pub fn to_phase_2<R>(
        &self,
        secret_key: &MemberCommunicationKey<G>,
        members_state: &[MembersFetchedState1<G>],
        rng: &mut R,
    ) -> MemberState2<G>
    where
        R: CryptoRng + RngCore,
    {
        let mut misbehaving_parties: Vec<MisbehavingPartiesState1<G>> = Vec::new();
        for fetched_data in members_state {
            if let (Some(comm), Some(shek)) =
                secret_key.decrypt_shares(fetched_data.indexed_shares.clone())
            {
                let index_pow =
                    <G::CorrespondingScalar as Scalar>::from_u64(self.owner_index as u64)
                        .exp_iter()
                        .take(self.threshold + 1);

                let check_element = self.ck.h * comm + G::generator() * shek;
                let multi_scalar = G::vartime_multiscalar_multiplication(
                    index_pow,
                    fetched_data.committed_coeffs.clone(),
                );

                if check_element != multi_scalar {
                    let proof = ProofOfMisbehaviour::generate(
                        &fetched_data.indexed_shares,
                        secret_key,
                        rng,
                    );
                    // todo: should we instead store the sender's index?
                    misbehaving_parties.push((
                        fetched_data.get_index(),
                        DkgError::ShareValidityFailed,
                        proof,
                    ));
                }
            } else {
                // todo: handle the proofs. Might not be the most optimal way of handling these two
                let proof =
                    ProofOfMisbehaviour::generate(&fetched_data.indexed_shares, secret_key, rng);
                misbehaving_parties.push((
                    fetched_data.get_index(),
                    DkgError::ScalarOutOfBounds,
                    proof,
                ));
            }
        }

        MemberState2 {
            misbehaving_parties,
            threshold: self.threshold,
        }
    }

    pub fn secret_key(&self) -> &MemberSecretShare<G> {
        &self.sk_share
    }

    pub fn public_key(&self) -> MemberPublicShare<G> {
        MemberPublicShare(PublicKey { pk: self.apubs[0] })
    }
}

impl<G: PrimeGroupElement> MemberState2<G> {
    pub fn validate(&self) -> Result<Self, DkgError> {
        if self.misbehaving_parties.len() == self.threshold {
            return Err(DkgError::MisbehaviourHigherThreshold);
        }

        Ok(self.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use curve25519_dalek::ristretto::RistrettoPoint;
    use rand_core::OsRng;

    #[test]
    fn valid_phase_2() {
        let mut rng = OsRng;

        let mut shared_string = b"Example of a shared string.".to_owned();
        let h = CommitmentKey::<RistrettoPoint>::generate(&mut shared_string);

        let mc1 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc2 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc = [mc1.to_public(), mc2.to_public()];

        let threshold = 2;
        let nr_members = 2;

        let m1 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 0,
        );
        let m2 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 1,
        );

        // Now, party one fetches the state of the other parties, mainly party two and three
        let fetched_state = vec![MembersFetchedState1 {
            indexed_shares: m2.encrypted_shares[0].clone(),
            committed_coeffs: m2.coeff_comms.clone(),
        }];

        let phase_2 = m1.to_phase_2(&mc1, &fetched_state, &mut rng);

        assert!(phase_2.validate().is_ok());
    }

    #[test]
    fn invalid_phase_2() {
        let mut rng = OsRng;

        let mut shared_string = b"Example of a shared string.".to_owned();
        let h = CommitmentKey::<RistrettoPoint>::generate(&mut shared_string);

        let mc1 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc2 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc3 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc = [mc1.to_public(), mc2.to_public(), mc3.to_public()];

        let threshold = 2;
        let nr_members = 3;

        let m1 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 0,
        );
        let m2 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 1,
        );
        let m3 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 2,
        );

        // Now, party one fetches invalid state of the other parties, mainly party two and three
        let fetched_state = vec![
            MembersFetchedState1 {
                indexed_shares: m2.encrypted_shares[0].clone(),
                committed_coeffs: vec![PrimeGroupElement::zero(); 3],
            },
            MembersFetchedState1 {
                indexed_shares: m3.encrypted_shares[0].clone(),
                committed_coeffs: vec![PrimeGroupElement::zero(); 3],
            },
        ];

        // Given that there is a number of misbehaving parties higher than the threshold, proceeding
        // to step 2 should fail.
        let phase_2_faked = m1.to_phase_2(&mc1, &fetched_state, &mut rng);
        assert_eq!(phase_2_faked.validate(), Err(DkgError::MisbehaviourHigherThreshold));
    }

    #[test]
    fn misbehaving_parties() {
        let mut rng = OsRng;

        let mut shared_string = b"Example of a shared string.".to_owned();
        let h = CommitmentKey::<RistrettoPoint>::generate(&mut shared_string);

        let mc1 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc2 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc3 = MemberCommunicationKey::<RistrettoPoint>::new(&mut rng);
        let mc = [mc1.to_public(), mc2.to_public(), mc3.to_public()];

        let threshold = 2;
        let nr_members = 3;

        let m1 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 0,
        );
        let m2 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 1,
        );
        let m3 = DistributedKeyGeneration::<RistrettoPoint>::init(
            &mut rng, threshold, nr_members, &h, &mc, 2,
        );

        // Now, party one fetches invalid state of a single party, mainly party two
        let fetched_state = vec![
            MembersFetchedState1 {
                indexed_shares: m2.encrypted_shares[0].clone(),
                committed_coeffs: m2.coeff_comms.clone(),
            },
            MembersFetchedState1 {
                indexed_shares: m3.encrypted_shares[0].clone(),
                committed_coeffs: vec![PrimeGroupElement::zero(); 3],
            },
        ];

        // Given that party 3 submitted encrypted shares which do not correspond to the
        // committed_coeffs, but party 2 submitted valid shares, phase 2 should be successful for
        // party 1, and there should be logs of misbehaviour of party 3

        let validated_phase_2 = m1.to_phase_2(&mc1, &fetched_state, &mut rng).validate();
        assert!(validated_phase_2.is_ok());

        let misbehaving_parties = validated_phase_2.unwrap().misbehaving_parties;
        // Party 2 should be good
        assert_eq!(misbehaving_parties.len(), 1);

        // Party 3 should fail
        // todo: mishandling of indices
        // assert_eq!(misbehaving_parties[0].0, 2);
        assert_eq!(misbehaving_parties[0].1, DkgError::ShareValidityFailed);
        // and the complaint should be valid
        assert!(misbehaving_parties[0].2.verify(&mc1.to_public(), &fetched_state[1], &h, 2, 2).is_err());
    }
}
